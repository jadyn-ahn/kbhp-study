# Chapter 3 - 재귀
재귀를 처음 배울 때 재귀적으로 사고해서 문제를 푸는게 더 쉽다면서 대표적인 Divide and Conquer 라고 설명을 들었었다.
한참 동안 그 말에 공감을 못하다가 동적 프로그래밍(dynamic programming) 문제 중 나무 토막을 어떻게 분해해서 판매해야 가장 
비싼 값을 받을지를 계산하는 문제에서 많이 공감했던 기억이 난다.


QuickSort와 GCD 기억이 하나도 안나서 위키피디아 찾아봤다.


## 머리재귀와 꼬리재귀
코틀린 컴파일러는 tailrec 키워드가 있는 함수를 while 문을 활용한 반복문으로 변경한다.
머리재귀와 꼬리재귀의 예시로 책에서 제시된 코드는 둘 다 while 문으로 변환이 가능하다. 머리재귀 코드도 변환이 가능한데 왜 꼬리재귀만 허용할까?
컴파일러가 알아내지 못하는 것으로 보인다. 즉, 꼬리재귀는 마지막 함수의 호출이 자기자신이기 때문에 꼬리재귀 함수가 호출되는 시점에 더 이상의 연산이 없음을 확신할 수 있다.
반대로 머리재귀의 경우, 그 뒤의 연산이 무엇인지 몰라도 남아있을 수 있고, 해당 연산이 다른 변수를 참조할 수 있기 떄문에 추가 연산에 대비하여 스택 정보를 가지고 있어야 한다. 즉, 최적화가 불가능하다.
예제 코드에서는 머리재귀 함수의 뒤쪽 연산이 단순히 상수를 참조하기 때문에 우연히 문제가 없어 보이지만, 상수 대신 현재 스택 프레임에서 계산되는 값을 참조하면 일반적인 while 문으로 변환이 불가능하다.

## 트램펄린
서로 다른 함수를 호출하는 구조에서, 기존 재귀와 문제가 되는 것은 어떤 함수를 호출해야 하는지가 동적으로 변화한다는 점이다.
지금 함수가 짝수 함수라면 홀수를, 홀수 함수라면 짝수를 호출해야 되기 때문에 자기 자신을 호출하는 재귀식으로 풀어내지지 않는다.
이 문제는 함수도 일급 객체로써 다루어서 유연하게 풀리는 것으로 보인다. 각 호출 시점에서 무엇을 호출할지를 변수에 담아 동적으로 해결한다.

한편 트램펄린 예제들에 대해서는 쓸데없다고 느껴진다. 뭘 이야기하고 싶은건지 모르겠다..



