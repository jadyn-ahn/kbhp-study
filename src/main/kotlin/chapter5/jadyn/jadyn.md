## 불변성을 이용한 자료구조 최적화
118쪽에 나오는 그림은 리스트 생성을 도식화한다. 리스트 내의 Cons들이 불변성을 만족하기에 리스트도 불변이고, 따라서 앞에 새로운 Cons를 붙이는 식으로 새로운 리스트를 만들어 내는게 가능하다.  반면 가변성을 이용하는 전통적인 구현에서는 메모리 내의 일렬 공간을 리스트(사실은 어레이지만)로 준비해두고 각 공간을 변경하는 방식으로 리스트를 구현한다. 따라서 새로운 리스트를 만들기 위해서는 공간을 통째로 복사해오는 방식을 취한다.

불변성 자료구조는 신기한 최적화를 가능하게 하는데 모든 리스트들이 하나의 데이터를 참조하게 하여 메모리 사용을 줄일 수 있다. 예를 들어 1, 2, 3, 4 등 Int 타입들은 프로그래밍을 하면서 빈번하게 사용된다. 코드 내에 1, 2, 3을 포함하는 리스트 또는 어레이도 따라서 많이 등장하는데, 이 값들이 불변이라면 메모리 상에 1, 2, 3을 딱 한번만 올려두고 이후 모든 어레이가 이 값들을 참조하게 할 수 있다. 만약 코드 내에 \[1,2,3\]과 \[1,2\]가 있다면 가변성 자료구조는 5개의 메모리칸에 1, 2, 3, 1, 2가 입력되어 있다면, 불변성 자료구조는 1, 2, 3만 메모리 공간에 올라와있고 나머지 리스트들은 전부 이 메모리를 참조한다.


## 타입 지원 && 패턴 매칭 중요성
언어적 레벨에서 지원되는 안전한 패턴 매칭은 타입 시스템의 활용도를 매우 높여주고, 그래서 함수형 구문들과 궁합이 잘 맞는다. FunList의 Nil과 Cons는 FunList를 상속받는 서로 다른 타입이고, 내부에 가지고 있는 프로퍼티도 다르다. 만약 자바였다면 안전하게 접근할 수 있는 수단이 없어서 타입 캐스팅 외에는 활용이 불가능하지만, 코틀린은 sealed class와 when과 같이 타입을 안전하게 매칭할 수 있는 기능 지원을 통해 타입 시스템의 활용을 가능하게 한다. 비단 코틀린만의 장점은 아니고 진보된 언어들은 이런 기능을 일반적으로 지원하며, 타입 시스템을 빡세게 사용하는 함수형과도 궁합이 잘 맞는다!