## 불변성을 이용한 자료구조 최적화
118쪽에 나오는 그림은 리스트 생성을 도식화한다. 리스트 내의 Cons들이 불변성을 만족하기에 리스트도 불변이고, 따라서 앞에 새로운 Cons를 붙이는 식으로 새로운 리스트를 만들어 내는게 가능하다.  반면 가변성을 이용하는 전통적인 구현에서는 메모리 내의 일렬 공간을 리스트(사실은 어레이지만)로 준비해두고 각 공간을 변경하는 방식으로 리스트를 구현한다. 따라서 새로운 리스트를 만들기 위해서는 공간을 통째로 복사해오는 방식을 취한다.

불변성 자료구조는 신기한 최적화를 가능하게 하는데 모든 리스트들이 하나의 데이터를 참조하게 하여 메모리 사용을 줄일 수 있다. 예를 들어 1, 2, 3, 4 등 Int 타입들은 프로그래밍을 하면서 빈번하게 사용된다. 코드 내에 1, 2, 3을 포함하는 리스트 또는 어레이도 따라서 많이 등장하는데, 이 값들이 불변이라면 메모리 상에 1, 2, 3을 딱 한번만 올려두고 이후 모든 어레이가 이 값들을 참조하게 할 수 있다. 만약 코드 내에 \[1,2,3\]과 \[1,2\]가 있다면 가변성 자료구조는 5개의 메모리칸에 1, 2, 3, 1, 2가 입력되어 있다면, 불변성 자료구조는 1, 2, 3만 메모리 공간에 올라와있고 나머지 리스트들은 전부 이 메모리를 참조한다.

## 타입 지원 && 패턴 매칭 중요성
언어적 레벨에서 지원되는 안전한 패턴 매칭은 타입 시스템의 활용도를 매우 높여주고, 그래서 함수형 구문들과 궁합이 잘 맞는다. FunList의 Nil과 Cons는 FunList를 상속받는 서로 다른 타입이고, 내부에 가지고 있는 프로퍼티도 다르다. 만약 자바였다면 안전하게 접근할 수 있는 수단이 없어서 타입 캐스팅 외에는 활용이 불가능하지만, 코틀린은 sealed class와 when과 같이 타입을 안전하게 매칭할 수 있는 기능 지원을 통해 타입 시스템의 활용을 가능하게 한다. 비단 코틀린만의 장점은 아니고 진보된 언어들은 이런 기능을 일반적으로 지원하며, 타입 시스템을 빡세게 사용하는 함수형과도 궁합이 잘 맞는다!

## 컬렉션을 다루는 추상화된 방법
지난 책에서 타입시스템을 공부하면서 제네릭 타입을 다룰 때 T라고 타입을 쓰게 되면 어떠한 연산도 기대하지 못하게 되는 것을 보았다. 컬렉션 내부에서 타입에 대한 연산을 기대하려면 T : Addable 과 같이 특정 타입의 하위 타입에 대한 컬렉션을 만들어서 해결했다. 이렇게 되면 컬렉션의 타입이 제한되면서 컬렉션의 활용도가 떨어지게 된다.
함수형 언어에서는 함수를 일급 객체로 다룰 수 있기 때문에 (aka 파라미터로 함수를 받을 수 있기 때문에) 컬렉션의 활용도가 매우 높아진다. 타입 선언 시점에서 컬렉션의 타입을 강제하지 않고, 컬렉션의 타입에 대해 가할 수 있는 연산을 별도로 파라미터로 받으면 컬렉션 자체는 타입에 대한 기대 없이 동작하게 된다. ex. List<T : Addable> / List<T>.fold(f: (T, T) -> T)

동작을 추상화하여 다루는데 클래스와 같이 고비용이 드는 언어 대신에 함수를 바로 객체로써 다룰 수 있어 저비용인 함수형 언어들은 동작에 대한 추상화를 훨씬 더 많이 쓰게되고, 동작이 가지는 표현력이 높기 때문에 언어 전체가 표현력이 높은 구성 요소들의 집합이 되도록 이끈다. 함수형 언어에서의 컬렉션은 '데이터의 집합체'라면 생각할 수 있는 모든 동작을 단일 코드로 표현한다고 해도 과언이 아니다.

## foldLeft와 foldRight의 성능 비교 설명
순서 개념을 넣었으면 더 좋았을 것 같다. head, tail 구조를 따르는 함수형 리스트에서 리스트에 대한 소비와 생성은 모두 head 쪽에서 진행된다. 따라서 어떤 리스트를 소비하면서 새로운 리스트를 생성한다면 소비 순서를 따라 생성이 되므로 리스트가 뒤집힌다. 따라서 리스트를 소비해서 리스트를 생성하는 경우, 소비 순서를 유지하는 foldLeft 연산은 생성에 불리하고 소비 순서를 뒤집는 foldRight는 생성에 유리하다.


