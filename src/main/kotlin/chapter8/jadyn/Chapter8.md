## 책 내용이 이해가 안가요 선생님
솔직히.. 보조자료가 필요하다..  
펑터에 대한 이해를 다시 복습하면서 '컨텍스트'의 개념으로 펑터 및 어플리케이티브 펑터를 바라보는게 쉬운게 아닌가 생각이 들었다. 이 링크가 설명을 쉽고 편하게 해준다. (그래도 2번은 읽어야 이해가 가더라..) https://m.blog.naver.com/dhnam0502/221568286398  

클래스 기반의 객체지향에서 많은 코드 작성에 대한 대가로 풍부한 표현력을 얻게 되는데, 함수형 언어에서는 간결하게 표현하면서도 표현력을 잃지 않기 위해 컨텍스트라는 해법을 찾은 것으로 보인다.

201쪽 "이것은 실제로 펑터 안에서 값을 꺼내는 번거로움 없이 연속적인 작업을 수행할 수 있게 한다."가 핵심적인 문장으로 보인다. 코드로는 8-18의 스타일을 달성하기 위한 시도들이라고 생각된다.

## 타입 클래스의 메타적 속성
8-3을 구현하다보니 Functor가 타입 클래스라는 생각이 확 들었다. Cons는 FunList이고 FunList는 Functor이기에 fmap이 구현되어야 하지만, fmap의 반환타입은 Cons지 Functor가 아니다.  
계속해서 FunList를 Applicative Functor로 구현을 하다보면 타입 클래스의 메타적인 속성에 대해서도 생각이 든다. FunList\<(A) -> B\>는 A -> B 타입의 함수들이 리스트에 담겨있는 구조다. 여기에 FunList\<A\>를 적용한다는 건 무엇을 의미할까? 나는 적어도 두 개의 해석이 생각난다. (1) 인덱스별로 나란히 적용한다. (2) 카르테시안 곱처럼 적용한다. 이 중 무엇이 정답일까? Applicative Functor는 컨텍스트 타입들이 Applicative Functor로 불리기 위해서 지켜야 할 규약을 담고 있을 뿐 구체적인 구현을 강제하지 않는다. (1)과 (2)가 모두 규칙을 만족한다면 둘 다 충분히 선택 가능한 구현이라고 인정받게 될 것 같다. => 오 실제로 뒤쪽 연습문제 8-6에서 집리스트(ZipList)로 언급이 된다.

뒤쪽 트리 구현의 예시에서 곱을 정의하는 것을 보면 카르테시안 곱이 선택된 것 같다. 재귀적 구조를 생각해보면 카르테시안 곱이 훨씬 안정적으로 보인다. 근데 그래도 이거 말고 다른 선택은 없나 생각하게 되기는 한다.. 행렬 곱을 처음 배웠을 때 당황했던 것처럼.. 이것도 뭔가 수학적 / 자료구조적 의미가 있겠지?
## 기타
코드 8-25보면 상당히 빡세다. 두 수의 곱을 나타내는 함수를 순식간에 두 트리의 곱을 구할 수 있게 끌어올리고 있다.

"각 법칙은 수학적으로 증명된 이론들이기 때문에, 법칙을 만족하는 펑터와 애플리케이티브 펑터들은 항상 기대한 동작을 한다는 것을 보장한다." => 기대한 동작이 뭔데요..?  

8장에서 나오는 컨텍스트를 유지하려는 모든 노력들은 실패 가능성이 있는 프로그램 전체를 Maybe로 감싼다고 생각하면 이해가 가는 것도 같다. 프로그램 전체에서 어딘가 실패할 수 있는 부분이 있기 마련이기에 프로그램 전체를 거대한 '실패 가능한 연산'으로 보는 방식. 기존에는 Exception을 던지는 순간 모든 연산이 종료되기에 값으로써 실패 가능성을 표현할 방법이 없지만, Maybe의 컨텍스트를 생각하면 컨텍스트 하에서 실패 가능성을 값으로서 처리가 가능하고 실패 가능성이 있는 지점 이후에 대해서도 값으로 다루고 검증할 수 있게 된다. 한번 exception을 던지면 그걸 잡아서 처리하는 로직을 작성하기란 여간 골치아픈게 아닌데, 함수형 패러다임처럼 컨텍스트와 리프팅 함수들을 조합하면 쉽게 가능해진다.





