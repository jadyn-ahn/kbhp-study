모나드는 중첩된 컨텍스트를 축약하는 정보를 가지고 있다. "이 법칙을 만족하면 타입과 타입이 가진 행위에 대한 합리적인 가정을 할 수 있다." -> 컨텍스트의 축약에 대해서 일반적으로 참으로 받아들여지는 지식이 있다. 앞서 배운 펑터나 어플리케이티브 펑터도 위와 같이 컨텍스트에 대해 일반적으로 참으로 받아들여지는 지식을 사용한다고 이해하면 되지 않을까.

IO 모나드 -> IO를 포함하는 컨텍스트. 순수 연산들도 붙으면 IO 모나드 컨텍스트로 끌려들어가고, IO 모나드 연산들은 동일한 컨텍스트(IO를 포함하고 있음)가 유지된다. 한번 모나드 컨텍스트에 포착되면 컨텍스트를 해제할 수 있는 방법이 없다. 이를 통해 컨텍스트의 분리를 강제한다.

모노이드는 모나드나 펑터와는 조금 다르게 느껴진다. 정확히 표현하면 리스트가 모노이드가 되는게 아니라 리스트는 "결합 하에서" 모노이드를 이룬다고 표현해야 한다. 리스트 모노이드로 만들기 이런 식으로 표현하니까 헷갈린다. 범주란 대상(원소)와 사상(함수)의 모임이라고 정의하는 것처럼, 리스트 모노이드는 리스트를 대상으로 하고 결합을 사상으로 포함해야 한다. 결합 외의 다른 연산들이 포함될 수 있지만 이는 모노이드를 구성하는데는 중요하지 않다.

추상적인 관점에서 바라본 후 구현단으로 내려오는 방식이 더 적절해보인다. FunList를 모노이드로 만드는 코드에서 mempty()는 새로운 기능이나 대상을 정의하는 것이 아니고, FunList에 포함되어 있는 대상(Nil과 여러 Cons들) 중 Nil을 결합 연산의 항등원으로써 지정한다는 선언이다.

책에서 '리스트 모노이드는 리스트의 기본적인 기능인 리스트 연결(concatenation) 기능을 제공한다.'고 표현하는데, 이것도 모노이드가 어떤 특성을 부여해주기 때문에 리스트에 연결 능력이 생긴다고 해석되기가 쉽다. 결합 연산의 부여가 선행이고 결합 연산 하에 모노이드를 이루는게 후행이다.

특정 연산 하에 모노이드를 이룬다는 사실을 알면! 그 다음부터는 그 연산이 구체적으로 무엇인지와 관계 없이 추상적인 관점에서의 '연결'을 활용하여 뻗어나갈 수 있다. 따라서 이제는 연산이 무엇인지는 잊어버리고 거꾸로 생각할 수 있기 때문에 '리스트는 모노이드야'의 쓰임새를 이해할 수 있다.
